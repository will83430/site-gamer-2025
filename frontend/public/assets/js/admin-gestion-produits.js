// Configuration
const API_URL = '/api';
let allProducts = [];
let currentEditingId = null;
let currentImageData = {};
let currentFicheData = {};

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    initImageColumn();
    loadStats();
    loadProducts();
    setupDragAndDrop();
    updateCategoryFields('new');

    // √âcouteurs pour le titre automatique - CORRECTION
    const newNomInput = document.getElementById('new-nom');
    const editNomInput = document.getElementById('edit-nom');

    if (newNomInput) {
        newNomInput.addEventListener('input', function () {
            const titreField = document.getElementById('new-titre-affiche');
            if (titreField && !titreField.value.trim()) {
                titreField.value = formatTitreAffiche(this.value);
            }
        });
    }

    if (editNomInput) {
        editNomInput.addEventListener('input', function () {
            const titreField = document.getElementById('edit-titre-affiche');
            if (titreField && !titreField.value.trim()) {
                titreField.value = formatTitreAffiche(this.value);
            }
        });
    }
});

// G√©rer la s√©lection de fichier HTML
function handleFicheSelect(event, prefix) {
    const file = event.target.files[0];
    if (!file) return;

    // R√©cup√©rer le nom du fichier
    const fileName = file.name;
    const pathInput = document.getElementById(`${prefix}-lien`);

    // Si le champ est vide, mettre juste le nom du fichier
    if (!pathInput.value) {
        pathInput.value = `fiches/${fileName}`;
    }

    // Lire le contenu du fichier HTML (optionnel)
    const reader = new FileReader();
    reader.onload = function (e) {
        currentFicheData[prefix] = {
            name: fileName,
            content: e.target.result
        };
        showMessage(`üìÑ Fichier "${fileName}" s√©lectionn√©`, 'success');
    };
    reader.readAsText(file);
}

// Afficher le s√©lecteur de fiches
async function showFicheSelector(prefix) {
    const selector = document.getElementById(`${prefix}-fiche-selector`);

    if (selector.style.display === 'block') {
        selector.style.display = 'none';
        return;
    }

    try {
        const response = await fetch(`${API_URL}/fiches-list`);
        const data = await response.json();

        if (data.success && data.files.length > 0) {
            // Grouper par dossier
            const grouped = data.files.reduce((acc, file) => {
                if (!acc[file.folder]) acc[file.folder] = [];
                acc[file.folder].push(file);
                return acc;
            }, {});

            let html = '<div style="font-size: 14px;">';
            Object.keys(grouped).sort().forEach(folder => {
                html += `<div style="margin-bottom: 10px;">
                        <strong style="color: #667eea;">üìÅ ${folder}/</strong>
                        <div style="margin-left: 20px; margin-top: 5px;">`;

                grouped[folder].forEach(file => {
                    html += `
                            <div style="padding: 5px; cursor: pointer; hover: background: #f0f0f0;" 
                                 onmouseover="this.style.background='#f0f0f0'" 
                                 onmouseout="this.style.background='none'"
                                 onclick="selectFiche('${prefix}', '${file.path}')">
                                üìÑ ${file.name}
                            </div>`;
                });

                html += '</div></div>';
            });
            html += '</div>';

            selector.innerHTML = html;
            selector.style.display = 'block';
        } else {
            selector.innerHTML = '<p style="color: #888;">Aucun fichier HTML trouv√© dans les dossiers de fiches</p>';
            selector.style.display = 'block';
        }
    } catch (error) {
        console.error('Erreur chargement fiches:', error);
        selector.innerHTML = '<p style="color: #dc3545;">Erreur lors du chargement des fiches</p>';
        selector.style.display = 'block';
    }
}

// S√©lectionner une fiche depuis la liste
function selectFiche(prefix, path) {
    document.getElementById(`${prefix}-lien`).value = path;
    document.getElementById(`${prefix}-fiche-selector`).style.display = 'none';
    showMessage(`‚úÖ Fiche s√©lectionn√©e: ${path}`, 'success');
}

// Initialiser la colonne image si n√©cessaire
async function initImageColumn() {
    try {
        await fetch(`${API_URL}/init-image-column`, { method: 'POST' });
    } catch (error) {
        console.error('Erreur init colonne:', error);
    }
}

// Navigation tabs
function showTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });

    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    document.getElementById(`${tabName}-tab`).classList.add('active');
    event.target.classList.add('active');
}

// Charger les statistiques
async function loadStats() {
    try {
        const response = await fetch(`${API_URL}/stats`);
        const data = await response.json();

        if (data.success) {
            document.getElementById('total-products').textContent = data.stats.total_products || 0;
            document.getElementById('total-categories').textContent = data.stats.total_categories || 0;
            document.getElementById('featured-products').textContent = data.stats.featured_products || 0;
        }
    } catch (error) {
        console.error('Erreur stats:', error);
    }
}

// REMPLACEZ la section ligne ~377-475 par ceci :

// Charger un produit pour √©dition
async function loadProductForEdit() {
    const select = document.getElementById('edit-product-select');
    const productId = select.value;

    if (!productId) {
        document.getElementById('edit-form-container').style.display = 'none';
        delete currentImageData['edit'];
        return;
    }

    delete currentImageData['edit'];

    try {
        const response = await fetch(`${API_URL}/produits/${productId}`);
        const data = await response.json();

        if (data.success) {
            const product = data.data;
            currentEditingId = productId;
            populateEditForm(product);
            document.getElementById('edit-form-container').style.display = 'block';

            // Forcer le rafra√Æchissement du titre apr√®s le chargement
            setTimeout(() => {
                const editNom = document.getElementById('edit-nom').value;
                const editTitre = document.getElementById('edit-titre-affiche');
                if (editTitre && !editTitre.value.trim() && editNom.trim()) {
                    editTitre.value = formatTitreAffiche(editNom);
                }
            }, 100);

            // Afficher l'image actuelle
            displayCurrentImage('edit', product.image);
        }
    } catch (error) {
        console.error('Erreur chargement:', error);
        showMessage('‚ùå Erreur lors du chargement', 'danger');
    }
}

// Remplir le formulaire d'√©dition
function populateEditForm(product) {
    document.getElementById('edit-nom').value = product.nom || '';
    document.getElementById('edit-titre-affiche').value = product.titre_affiche || '';
    document.getElementById('edit-categorie').value = product.categorie || '';
    document.getElementById('edit-prix').value = product.prix || '';
    document.getElementById('edit-description').value = product.description || '';
    document.getElementById('edit-lien').value = product.lien || '';
    document.getElementById('edit-top').value = product.top_du_mois ? 'true' : 'false';

    const fonctionnalites = Array.isArray(product.fonctionnalites_avancees)
        ? product.fonctionnalites_avancees.join('\n')
        : '';
    document.getElementById('edit-fonctionnalites').value = fonctionnalites;

    // Afficher l'image existante
    if (product.image) {
        let imageUrl = product.image;
        let imageFileName = product.image;

        // Extraire juste le nom du fichier pour currentImageData
        if (imageUrl.startsWith('assets/images/')) {
            imageFileName = imageUrl.replace('assets/images/', '');
            imageUrl = imageUrl;
        } else if (imageUrl.startsWith('/')) {
            imageFileName = imageUrl.substring(1);
            imageUrl = `assets/images/${imageFileName}`;
        } else if (!imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
            imageFileName = imageUrl;
            imageUrl = `assets/images/${imageUrl}`;
        }

        const editUploadArea = document.getElementById('edit-upload-area');
        const editImagePreview = document.getElementById('edit-image-preview');
        const editPreviewImg = document.getElementById('edit-preview-img');

        if (editUploadArea) editUploadArea.style.display = 'none';
        if (editImagePreview) editImagePreview.style.display = 'block';
        if (editPreviewImg) editPreviewImg.src = imageUrl;
        
        // Stocker juste le nom du fichier
        currentImageData['edit'] = imageFileName;
    }

    updateCategoryFields('edit', product.donnees_fiche);
    autoFillFichePath('edit');
}

// Nouvelle fonction pour afficher l'image actuelle
function displayCurrentImage(prefix, imageFileName) {
    const currentImageDiv = document.getElementById(`${prefix}-current-image`);
    const currentImg = document.getElementById(`${prefix}-current-img`);
    const actionsDiv = document.getElementById(`${prefix}-image-actions`);
    
    if (imageFileName && imageFileName.trim() !== '') {
        // Afficher l'image actuelle
        currentImg.src = `/assets/images/${imageFileName}`;
        currentImg.title = "üîç Cliquez pour voir en grand - Survolez pour agrandir";
        
        // Ajouter l'√©v√©nement de clic pour afficher en modal
        currentImg.onclick = function() {
            showImageModal(`/assets/images/${imageFileName}`, imageFileName);
        };
        
        currentImg.onerror = function() {
            this.src = '/assets/images/placeholder.png';
            this.title = "Image non trouv√©e";
        };
        
        currentImageDiv.style.display = 'block';
        actionsDiv.style.display = 'block';
        
        // Modifier le texte de la zone d'upload
        const uploadZone = document.getElementById(`${prefix}-upload-zone`);
        const uploadText = uploadZone.querySelector('.upload-text');
        const uploadHint = uploadZone.querySelector('.upload-hint');
        
        uploadText.textContent = 'Remplacer par une nouvelle image';
        uploadHint.textContent = 'ou cliquez pour parcourir (JPG, PNG, WebP - Max 5MB)';
    } else {
        // Pas d'image actuelle
        currentImageDiv.style.display = 'none';
        actionsDiv.style.display = 'none';
        
        // Remettre le texte par d√©faut
        const uploadZone = document.getElementById(`${prefix}-upload-zone`);
        const uploadText = uploadZone.querySelector('.upload-text');
        const uploadHint = uploadZone.querySelector('.upload-hint');
        
        uploadText.textContent = 'Glissez votre image ici';
        uploadHint.textContent = 'ou cliquez pour parcourir (JPG, PNG, WebP - Max 5MB)';
    }
}

// Mettre √† jour un produit
async function updateProduct(event) {
    event.preventDefault();

    if (!currentEditingId) return;

    // R√©cup√©rer les valeurs
    const nom = document.getElementById('edit-nom').value;
    let titreAffiche = document.getElementById('edit-titre-affiche').value.trim();

    // Si titre_affiche est vide, le g√©n√©rer automatiquement
    if (!titreAffiche) {
        titreAffiche = formatTitreAffiche(nom);
        document.getElementById('edit-titre-affiche').value = titreAffiche;
    }

    const productData = {
        nom: nom,
        titre_affiche: titreAffiche, // Maintenant toujours rempli
        categorie: document.getElementById('edit-categorie').value,
        prix: document.getElementById('edit-prix').value,
        description: document.getElementById('edit-description').value,
        lien: document.getElementById('edit-lien').value,
        top_du_mois: document.getElementById('edit-top').value === 'true',
        fonctionnalites_avancees: document.getElementById('edit-fonctionnalites').value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData('edit')
    };

    // Ajouter l'image si pr√©sente
    if (currentImageData['edit']) {
        const fileInput = document.getElementById('edit-image-file');
        if (fileInput && fileInput.files[0]) {
            // Nouveau fichier - juste le nom
            productData.image = fileInput.files[0].name;
        } else if (typeof currentImageData['edit'] === 'string' && 
                   currentImageData['edit'].trim() && 
                   !currentImageData['edit'].startsWith('data:')) {
            // Image existante - nettoyer le nom
            let imageName = currentImageData['edit'];
            
            if (imageName.startsWith('assets/images/')) {
                imageName = imageName.replace('assets/images/', '');
            }
            if (imageName.startsWith('/')) {
                imageName = imageName.substring(1);
            }
            
            productData.image = imageName;
        }
    }

    try {
        const response = await fetch(`${API_URL}/produits/${currentEditingId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(productData)
        });

        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit mis √† jour avec succ√®s!', 'success');
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        console.error('Erreur mise √† jour:', error);
        showMessage('‚ùå Erreur lors de la mise √† jour', 'danger');
    }
}

// Supprimer un produit
async function deleteProduct() {
    if (!currentEditingId) return;

    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer ce produit?')) return;

    try {
        // 1. Supprimer la fiche locale AVANT la BDD
        await fetch(`${API_URL}/fiches/${currentEditingId}`, { method: 'DELETE' });

        // 2. Supprimer le produit en BDD
        const response = await fetch(`${API_URL}/produits/${currentEditingId}`, {
            method: 'DELETE'
        });
        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit et fiche supprim√©s avec succ√®s!', 'success');
            document.getElementById('edit-form-container').style.display = 'none';
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        showMessage('‚ùå Erreur lors de la suppression', 'danger');
    }
}

// Supprimer un produit (raccourci depuis la colonne Actions)  
async function confirmDelete(productId) {
    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer ce produit ?')) {
        return;
    }

    try {
        // 1. Supprimer la fiche locale AVANT la BDD
        await fetch(`${API_URL}/fiches/${productId}`, { method: 'DELETE' });

        // 2. Supprimer le produit en BDD
        const response = await fetch(`${API_URL}/produits/${productId}`, {
            method: 'DELETE'
        });
        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit et fiche supprim√©s avec succ√®s !', 'success');
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        showMessage('‚ùå Erreur lors de la suppression', 'danger');
    }
}

// √âditer un produit (raccourci depuis la colonne Actions)
function editProduct(productId) {
    // Aller dans l'onglet modifier
    showTab('modify');

    // S√©lectionner le produit dans la liste d√©roulante
    const select = document.getElementById('edit-product-select');
    if (select) {
        select.value = productId;
        // D√©clencher le chargement du formulaire
        loadProductForEdit();
    } else {
        console.error('‚ùå Element edit-product-select non trouv√©');
    }
}

async function generateFicheFromEdit() {
    if (!currentEditingId) {
        showMessage('S√©lectionnez un produit', 'warning');
        return;
    }

    try {
        const response = await fetch(`${API_URL}/generate-fiche/${currentEditingId}`, {
            method: 'POST'
        });

        const data = await response.json();
        if (data.success) {
            showMessage(`Fiche g√©n√©r√©e: ${data.path}`, 'success');
        } else {
            showMessage(`Erreur: ${data.error}`, 'danger');
        }
    } catch (error) {
        showMessage('Erreur de g√©n√©ration', 'danger');
    }
}

// Peupler le select d'√©dition
function populateEditSelect(products) {
    const select = document.getElementById('edit-product-select');
    select.innerHTML = '<option value="">-- Choisir un produit --</option>';

    const grouped = products.reduce((acc, product) => {
        const cat = product.categorie || 'Sans cat√©gorie';
        if (!acc[cat]) acc[cat] = [];
        acc[cat].push(product);
        return acc;
    }, {});

    Object.keys(grouped).sort().forEach(category => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;

        grouped[category].forEach(product => {
            const option = document.createElement('option');
            option.value = product.id;
            option.textContent = `${product.nom} - ${product.prix || 'N/A'}`;
            optgroup.appendChild(option);
        });

        select.appendChild(optgroup);
    });
}

// Mettre √† jour les champs sp√©cifiques √† la cat√©gorie
function updateCategoryFields(prefix, existingData = null) {
    const category = document.getElementById(`${prefix}-categorie`).value;
    const container = document.getElementById(`${prefix}-category-fields`);

    if (!category) {
        container.innerHTML = '';
        return;
    }

    const fields = getCategorySpecificFields(category);

    // 1. R√©cup√®re les valeurs d√©j√† saisies AVANT de r√©g√©n√©rer le HTML
    let previousValues = [];
    for (let i = 0; i < fields.length; i++) {
        const textarea = document.getElementById(`${prefix}-fiche-${i}`);
        if (textarea) {
            previousValues[i] = textarea.value;
        }
    }

    container.innerHTML = `
        <h3 style="margin-top: 30px; margin-bottom: 20px; color: #667eea;">
            üìã Donn√©es de fiche pour ${category}
        </h3>
        ${fields.map((field, index) => {
            // Priorit√© : existingData (√©dition) > texte d√©j√† saisi > vide
            let value = '';
            if (existingData && existingData[index]) {
                const contenu = existingData[index];
                // G√©rer les \n √©chapp√©s
                const contenuNettoye = contenu.replace(/\\n/g, '\n');

                if (contenuNettoye.includes('\n') && /^[^\w\s]/.test(contenuNettoye)) {
                    value = contenuNettoye.split('\n').slice(1).join('\n');
                } else {
                    value = contenu;
                }
            } else if (previousValues[index]) {
                value = previousValues[index];
            }
            return `
                <div class="form-group">
                    <label>${field.emoji} ${field.label}</label>
                    <textarea 
                        id="${prefix}-fiche-${index}" 
                        rows="3"
                        placeholder="${field.placeholder || ''}"
                    >${value}</textarea>
                </div>
            `;
        }).join('')}
    `;
}

// Obtenir les champs sp√©cifiques √† une cat√©gorie
function getCategorySpecificFields(category) {
    const baseFields = [
        { emoji: "üìù", label: "Description d√©taill√©e", placeholder: "Description compl√®te du produit" },
        { emoji: "üí∞", label: "Prix", placeholder: "Ex: 1299‚Ç¨ - Prix comp√©titif" },
        { emoji: "üß©", label: "Sp√©cifications mat√©rielles", placeholder: "Processeur, RAM, stockage..." }
    ];

    const categorySpecific = {
        'DRONE': [
            { emoji: "üé•", label: "Fonctions vid√©o et photo", placeholder: "R√©solution, stabilisation, modes photo..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Bluetooth, radio..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Pilotage, application mobile..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Batteries, h√©lices, sacoche..." }
        ],
        'CONSOLE': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "R√©solution, taux de rafra√Æchissement..." },
            { emoji: "üïπÔ∏è", label: "Contr√¥leurs et interaction", placeholder: "Manettes, accessoires..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Ethernet, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience de jeu", placeholder: "Interface, exclusivit√©s..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Manettes, c√¢bles..." }
        ],
        'TABLETTE': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution, technologie..." },
            { emoji: "üñäÔ∏è", label: "Accessoires et interaction", placeholder: "Stylet, clavier..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, 4G/5G, Bluetooth..." },
            { emoji: "üéÆ", label: "Applications et usages", placeholder: "Productivit√©, jeux..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'SMARTPHONE': [
            { emoji: "üì∏", label: "Appareil photo", placeholder: "Nombre de capteurs, r√©solution..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "5G, Wi-Fi, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, OS..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Chargeur, c√¢ble..." }
        ],
        'PC GAMING': [
            { emoji: "üéÆ", label: "Performances gaming", placeholder: "GPU, CPU, FPS..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Ethernet, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Refroidissement, bruit..." },
            { emoji: "üîã", label: "Gestion thermique", placeholder: "Ventilation, watercooling..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Souris, clavier..." }
        ],
        'SERVEUR': [
            { emoji: "üñ•Ô∏è", label: "Performances et virtualisation", placeholder: "CPU, RAM, hyperviseur..." },
            { emoji: "üåê", label: "Connectivit√© r√©seau", placeholder: "Ethernet, fibre..." },
            { emoji: "üéÆ", label: "Gestion et monitoring", placeholder: "Logiciels, alertes..." },
            { emoji: "üîí", label: "S√©curit√© et redondance", placeholder: "RAID, alimentation..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'CASQUE AUDIO': [
            { emoji: "üéß", label: "Fonctions audio", placeholder: "ANC, spatialisation..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Bluetooth, filaire..." },
            { emoji: "üéÆ", label: "Confort et utilisation", placeholder: "Poids, coussinets..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'MONTRE CONNECTEE': [
            { emoji: "‚åö", label: "Fonctions sport et sant√©", placeholder: "Cardio, GPS, sommeil..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Bluetooth, Wi-Fi..." },
            { emoji: "üéÆ", label: "Applications et autonomie", placeholder: "App store, batterie..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'CAMERA': [
            { emoji: "üé•", label: "Fonctions vid√©o et photo", placeholder: "R√©solution, formats, modes..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, ergonomie..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Objectifs, c√¢bles..." }
        ],
        'PERIPHERIQUES': [
            { emoji: "üéõÔ∏è", label: "Fonctions avanc√©es", placeholder: "Macros, RGB, capteurs..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Bluetooth, sans fil..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Ergonomie, confort..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Accessoires inclus..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." }
        ],
        'CASQUE VR': [
            { emoji: "üïπÔ∏è", label: "Contr√¥leurs et interaction", placeholder: "Manettes, capteurs..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Bluetooth, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience immersive", placeholder: "Champ de vision, confort..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'IMPRIMANTE 3D': [
            { emoji: "üñ®Ô∏è", label: "Fonctions d'impression", placeholder: "Technologie, mat√©riaux..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Logiciel, calibration..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'ECRAN TV': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution, HDR..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "HDMI, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, t√©l√©commande..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'VIDEO PROJECTEUR': [
            { emoji: "üé•", label: "Fonctions vid√©o", placeholder: "R√©solution, luminosit√©..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "HDMI, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Installation, r√©glages..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'BOX INTERNET': [
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Ethernet, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, installation..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'TABLEAU INTERACTIF': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution..." },
            { emoji: "üñäÔ∏è", label: "Accessoires et interaction", placeholder: "Stylet, support..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, HDMI..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Logiciel, ergonomie..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ]
    };

    return [
        ...baseFields,
        ...(categorySpecific[category] || [])
    ];
}

// Collecter les donn√©es de cat√©gorie AVEC LABELS ET IC√îNES
function collectCategoryData(prefix) {
    const data = [];
    const category = document.getElementById(`${prefix}-categorie`).value;
    const fields = getCategorySpecificFields(category);

    for (let index = 0; index < fields.length; index++) {
        const field = document.getElementById(`${prefix}-fiche-${index}`);
        if (!field) continue;
        // Format : "üìù Description d√©taill√©e\nLe contenu saisi"
        data.push(`${fields[index].emoji} ${fields[index].label}\n${field.value.trim()}`);
    }
    return data;
}

// Afficher un message
function showMessage(message, type) {
    const container = document.getElementById('message-container');
    container.innerHTML = `
        <div class="alert alert-${type}">
            ${message}
        </div>
    `;

    setTimeout(() => {
        container.innerHTML = '';
    }, 5000);
}

// Raccourcis clavier
document.addEventListener('keydown', (e) => {
    // Ctrl+N : Nouveau produit
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        showTab('create');
    }

    // Ctrl+E : √âditer
    if (e.ctrlKey && e.key === 'e') {
        e.preventDefault();
        showTab('modify');
    }

    // Ctrl+L : Liste
    if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        showTab('list');
    }
});

// Auto-refresh toutes les 30 secondes
setInterval(() => {
    loadStats();
}, 30000);


// Remplacer l'ancien setupDragAndDrop
// REMPLACEZ setupDragAndDrop (ligne ~1147) :

function setupDragAndDrop() {
    setTimeout(() => {
        if (!window.dragDropInitialized) {
            modernUpload.new = new ModernImageUpload('new');
            modernUpload.edit = new ModernImageUpload('edit');
            window.dragDropInitialized = true;
        }
    }, 200);
}

/**
 * Sauvegarde un produit (cr√©ation ou modification) et g√©n√®re la fiche HTML.
 * @param {'new'|'edit'} mode - 'new' pour cr√©ation, 'edit' pour modification
 */
async function saveProductAndGenerateFiche(mode) {
    const isEdit = mode === 'edit';
    const prefix = isEdit ? 'edit' : 'new';
    const id = isEdit ? currentEditingId : null;

    let titreAfficheValue = document.getElementById(`${prefix}-titre-affiche`).value.trim();
    if (!titreAfficheValue) {
        titreAfficheValue = formatTitreAffiche(document.getElementById(`${prefix}-nom`).value);
    }

    const productData = {
        nom: document.getElementById(`${prefix}-nom`).value,
        titre_affiche: titreAfficheValue,
        categorie: document.getElementById(`${prefix}-categorie`).value,
        prix: document.getElementById(`${prefix}-prix`).value,
        description: document.getElementById(`${prefix}-description`).value,
        lien: document.getElementById(`${prefix}-lien`).value,
        top_du_mois: document.getElementById(`${prefix}-top`).value === 'true',
        fonctionnalites_avancees: document.getElementById(`${prefix}-fonctionnalites`).value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData(prefix)
    };

    if (currentImageData[prefix]) {
        const fileInput = document.getElementById(`${prefix}-image-file`);
        if (fileInput && fileInput.files[0]) {
            // Nouveau fichier s√©lectionn√© - stocker JUSTE le nom du fichier
            productData.image = fileInput.files[0].name;
        } else if (typeof currentImageData[prefix] === 'string' && 
                   currentImageData[prefix].trim() && 
                   !currentImageData[prefix].startsWith('data:')) {
            // Image existante - nettoyer pour ne garder que le nom du fichier
            let imageName = currentImageData[prefix];
            
            // Supprimer le chemin assets/images/ s'il existe
            if (imageName.startsWith('assets/images/')) {
                imageName = imageName.replace('assets/images/', '');
            }
            
            // Supprimer le / au d√©but s'il existe
            if (imageName.startsWith('/')) {
                imageName = imageName.substring(1);
            }
            
            productData.image = imageName;
        }
    }

    // Validation
    if (!productData.nom || !productData.categorie) {
        showMessage('‚ö†Ô∏è Nom et cat√©gorie sont obligatoires', 'warning');
        return;
    }

    try {
        // 1. Cr√©ation ou modification du produit
        let response, data;
        if (isEdit) {
            response = await fetch(`${API_URL}/produits/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(productData)
            });
        } else {
            response = await fetch(`${API_URL}/produits`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(productData)
            });
        }
        data = await response.json();

        if (!data.success) {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
            return;
        }

        const productId = isEdit ? id : data.data.id;

        // 2. G√©n√©rer la fiche HTML
        const ficheResponse = await fetch(`${API_URL}/generate-fiche/${productId}`, {
            method: 'POST'
        });
        const ficheData = await ficheResponse.json();

        if (ficheData.success) {
            showMessage(`‚úÖ Produit ${isEdit ? 'modifi√©' : 'cr√©√©'} et fiche g√©n√©r√©e: ${ficheData.path}`, 'success');
        } else {
            showMessage(`‚úÖ Produit ${isEdit ? 'modifi√©' : 'cr√©√©'} mais erreur fiche: ${ficheData.error}`, 'warning');
        }

        if (!isEdit) resetCreateForm();
        loadProducts();
        loadStats();

    } catch (error) {
        console.error('Erreur:', error);
        showMessage('‚ùå Erreur lors du processus', 'danger');
    }
}

function autoFillFichePath(prefix) {
    const nom = document.getElementById(`${prefix}-nom`).value.trim();
    const categorie = document.getElementById(`${prefix}-categorie`).value.trim();
    if (!nom || !categorie) return;

    // Formatage du chemin
    const catSlug = categorie.toLowerCase().replace(/\s+/g, '-');
    const nomSlug = nom.normalize("NFD").replace(/[\u0300-\u036f]/g, "") // retire accents
        .replace(/[^a-zA-Z0-9]/g, '-') // remplace tout sauf lettres/chiffres par tiret
        .replace(/-+/g, '-') // √©vite les doubles tirets
        .replace(/^-|-$/g, '') // pas de tiret au d√©but/fin
        .toLowerCase();

    const path = `fiches/${catSlug}/${nomSlug}.html`;
    document.getElementById(`${prefix}-lien`).value = path;
}

function formatTitreAffiche(nom) {
    if (!nom) return '';

    // Liste d'acronymes et termes √† garder en majuscules
    const keepUppercase = ['EOS', 'RAM', 'SSD', 'HDD', 'CPU', 'GPU', 'LED', 'LCD', 'HDR', 'USB', 'HD', 'UHD', 'FHD', '4K', '8K', 'PS5', 'PS4', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];

    return nom
        .replace(/-/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .split(' ')
        .map(word => {
            // V√©rifier si le mot (en majuscules) est dans la liste √† conserver en majuscules
            if (keepUppercase.includes(word.toUpperCase())) {
                return word.toUpperCase();
            }
            // Sinon, appliquer la capitalisation standard
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        })
        .join(' ');
}

// NOUVELLES FONCTIONS DE PR√âVISUALISATION

// Fonction de pr√©visualisation
function previewProduct(prefix) {
    const nom = document.getElementById(`${prefix}-nom`).value || 'Nom du produit';
    const prix = document.getElementById(`${prefix}-prix`).value || 'Prix non communiqu√©';
    const description = document.getElementById(`${prefix}-description`).value || 'Description non disponible';
    const topDuMois = document.getElementById(`${prefix}-top`).value === 'true';
    const fonctionnalitesText = document.getElementById(`${prefix}-fonctionnalites`).value;
    
    // R√©cup√©rer l'image
    let imageUrl = 'assets/images/placeholder.png';
    if (currentImageData[prefix]) {
        if (typeof currentImageData[prefix] === 'string' && currentImageData[prefix].startsWith('data:')) {
            // Base64 image from file upload
            imageUrl = currentImageData[prefix];
        } else if (typeof currentImageData[prefix] === 'string') {
            // Existing image path
            imageUrl = currentImageData[prefix].startsWith('assets/images/') 
                ? currentImageData[prefix] 
                : `assets/images/${currentImageData[prefix]}`;
        }
    }
    
    // Parser les fonctionnalit√©s
    const fonctionnalites = fonctionnalitesText 
        ? fonctionnalitesText.split('\n').filter(f => f.trim()).slice(0, 3)
        : [];

    // G√©n√©rer le HTML de pr√©visualisation
    const previewHTML = `
        ${topDuMois ? '<span class="top-badge">‚≠ê TOP</span>' : ''}
        <img src="${imageUrl}" alt="${nom}" onerror="this.src='assets/images/placeholder.png'">
        <h3 style="color: #667eea; margin: 15px 0;">${nom}</h3>
        <p style="color: #666; margin: 10px 0;">${description}</p>
        <p style="color: #667eea; font-weight: bold; font-size: 18px;">${prix}</p>
        ${fonctionnalites.length > 0 ? `
            <ul style="text-align: left; padding-left: 20px; margin: 15px 0;">
                ${fonctionnalites.map(f => `<li style="color: #333;">${f}</li>`).join('')}
            </ul>
        ` : ''}
    `;

    document.getElementById('fichePreview').innerHTML = previewHTML;
    document.getElementById('previewModal').style.display = 'block';
}

// Fermer la pr√©visualisation
function closePreview() {
    document.getElementById('previewModal').style.display = 'none';
}

// Changer le format d'affichage (si vous avez des boutons device)
function changeDevice(device) {
    const preview = document.getElementById('fichePreview');
    const buttons = document.querySelectorAll('.device-btn');
    
    // Reset classes
    buttons.forEach(btn => btn.classList.remove('active'));
    preview.className = 'fiche-preview';
    
    // Appliquer la nouvelle classe
    if (event && event.target) {
        event.target.classList.add('active');
        preview.classList.add(`${device}-preview`);
    }
}

// Event listeners pour la modal
document.addEventListener('DOMContentLoaded', function() {
    // Fermer avec Escape
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const modal = document.getElementById('previewModal');
            if (modal && modal.style.display === 'block') {
                closePreview();
            }
        }
    });

    // Fermer en cliquant √† c√¥t√©
    const previewModal = document.getElementById('previewModal');
    if (previewModal) {
        previewModal.addEventListener('click', function(e) {
            if (e.target === this) {
                closePreview();
            }
        });
    }
});

// NOUVELLES FONCTIONS DE PR√âVISUALISATION - √Ä AJOUTER DANS LE JS
async function previewGeneratedFiche(prefix) {
    
    const nom = document.getElementById(`${prefix}-nom`).value;
    const lien = document.getElementById(`${prefix}-lien`).value;
    
    
    if (!nom) {
        showMessage('‚ö†Ô∏è Veuillez saisir un nom de produit', 'warning');
        return;
    }

    // Si on est en mode √©dition et qu'un produit est s√©lectionn√©
    if (prefix === 'edit' && currentEditingId) {
        return previewFicheFromId(currentEditingId);
    } 
    
    // Mode cr√©ation : v√©rifier si un lien de fiche est sp√©cifi√©
    if (lien && lien.trim()) {
        const fichePath = lien.startsWith('/') ? lien.substring(1) : lien;
        
        try {
            // V√©rifier que le fichier existe
            const response = await fetch(`/${fichePath}`, { method: 'HEAD' });
            
            if (response.ok) {
                // Le fichier existe - l'ouvrir dans un nouvel onglet
                const ficheUrl = `${window.location.origin}/${fichePath}`;
                window.open(ficheUrl, '_blank');
                showMessage('üìÑ Fiche ouverte dans un nouvel onglet !', 'success');
            } else {
                showMessage(`‚ùå Fichier de fiche non trouv√© : ${fichePath}`, 'danger');
            }
            
        } catch (error) {
            console.error('‚ùå Erreur ouverture fichier:', error);
            showMessage('‚ùå Erreur lors de l\'ouverture du fichier de fiche', 'danger');
        }
    } else {
        showMessage('‚ö†Ô∏è Aucun lien de fiche sp√©cifi√©. Saisissez d\'abord un produit et g√©n√©rez sa fiche.', 'warning');
    }
}

async function previewFicheFromId(productId) {
    
    try {
        // 1. R√©cup√©rer les infos du produit pour conna√Ætre le chemin de sa fiche
        const productResponse = await fetch(`${API_URL}/produits/${productId}`);
        const productData = await productResponse.json();
        
        if (!productData.success) {
            showMessage(`‚ùå Erreur: ${productData.error}`, 'danger');
            return;
        }
        
        const product = productData.data;
        
        // 2. Construire le chemin vers la fiche g√©n√©r√©e
        let fichePath = product.lien;
        
        // Si pas de lien, construire le chemin automatiquement
        if (!fichePath) {
            const catSlug = product.categorie.toLowerCase().replace(/\s+/g, '-');
            const nomSlug = product.nom.normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "") 
                .replace(/[^a-zA-Z0-9]/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '')
                .toLowerCase();
            fichePath = `fiches/${catSlug}/${nomSlug}.html`;
        }
        
        // Nettoyer le chemin
        if (fichePath.startsWith('/')) {
            fichePath = fichePath.substring(1);
        }
        
        
        // 3. V√©rifier que la fiche existe
        try {
            const ficheResponse = await fetch(`/${fichePath}`, { method: 'HEAD' });
            
            if (ficheResponse.ok) {
                // ‚úÖ La fiche existe - l'ouvrir dans un nouvel onglet
                const ficheUrl = `${window.location.origin}/${fichePath}`;
                
                window.open(ficheUrl, '_blank');
                showMessage('üìÑ Fiche ouverte dans un nouvel onglet !', 'success');
                
            } else {
                
                // Proposer de g√©n√©rer la fiche
                if (confirm(`‚ùì La fiche n'existe pas encore.\nVoulez-vous la g√©n√©rer maintenant ?`)) {
                    await generateAndOpenFiche(productId, fichePath);
                } else {
                    showMessage('‚ö†Ô∏è Fiche non trouv√©e sur le disque', 'warning');
                }
            }
            
        } catch (ficheError) {
            
            // Proposer de g√©n√©rer la fiche
            if (confirm(`‚ùì Impossible de v√©rifier si la fiche existe.\nVoulez-vous tenter de la g√©n√©rer ?`)) {
                await generateAndOpenFiche(productId, fichePath);
            } else {
                showMessage('‚ùå Erreur lors de la v√©rification de la fiche', 'danger');
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erreur globale:', error);
        showMessage('‚ùå Erreur lors du chargement des informations du produit', 'danger');
    }
}

// Fonction pour g√©n√©rer une fiche et l'ouvrir
async function generateAndOpenFiche(productId, fichePath) {
    try {
        showMessage('‚è≥ G√©n√©ration de la fiche en cours...', 'info');
        
        // G√©n√©rer la fiche
        const response = await fetch(`${API_URL}/generate-fiche/${productId}`, {
            method: 'POST'
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Attendre un peu que le fichier soit √©crit
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Ouvrir la fiche g√©n√©r√©e
            const ficheUrl = `${window.location.origin}/${fichePath}`;
            window.open(ficheUrl, '_blank');
            
            showMessage(`‚úÖ Fiche g√©n√©r√©e et ouverte : ${data.path}`, 'success');
        } else {
            showMessage(`‚ùå Erreur de g√©n√©ration : ${data.error}`, 'danger');
        }
        
    } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration:', error);
        showMessage('‚ùå Erreur lors de la g√©n√©ration de la fiche', 'danger');
    }
}

// AJOUTEZ cette fonction si elle n'existe pas :

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// AJOUTEZ cette fonction pour r√©tablir les event listeners :

// REMPLACEZ setupImageUpload pour forcer le nettoyage :

function setupImageUpload(prefix) {
    setTimeout(() => {
        const uploadZone = document.getElementById(`${prefix}-upload-zone`);
        const fileInput = document.getElementById(`${prefix}-image-file`);
        
        if (!uploadZone || !fileInput) {
            console.warn(`‚ö†Ô∏è √âl√©ments upload manquants pour ${prefix}`);
            return;
        }

        // IMPORTANT : Ne pas utiliser outerHTML qui casse l'interaction
        // Au lieu de √ßa, supprimer les event listeners manuellement
        uploadZone.onclick = null;
        uploadZone.ondragover = null;
        uploadZone.ondragleave = null;
        uploadZone.ondrop = null;
        fileInput.onchange = null;

        // Variable de protection globale
        if (!window.clickProtection) window.clickProtection = {};
        
        // Event listener DIRECT sans preventDefault excessif
        uploadZone.addEventListener('click', function(e) {
            // Protection contre les doubles clics
            const now = Date.now();
            if (window.clickProtection[prefix] && (now - window.clickProtection[prefix]) < 1000) {
                return;
            }
            
            window.clickProtection[prefix] = now;
            
            // CORRECTION : D√©clencher le clic DIRECTEMENT
            fileInput.click();
        }, { passive: true });

        // Event listener pour le changement de fichier
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && validateImageFile(file)) {
                showImagePreview(prefix, file);
            }
        });

        // Drag & Drop
        uploadZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (validateImageFile(file)) {
                    // Assigner les fichiers √† l'input
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    fileInput.files = dt.files;
                    
                    showImagePreview(prefix, file);
                }
            }
        });

        
    }, 100); // R√©duire le d√©lai
}

// Fonction de validation
function validateImageFile(file) {
    const maxSize = 5 * 1024 * 1024; // 5MB
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    
    if (!allowedTypes.includes(file.type)) {
        showMessage('‚ùå Type de fichier non support√©. Utilisez JPG, PNG, WebP ou GIF.', 'danger');
        return false;
    }
    
    if (file.size > maxSize) {
        showMessage(`‚ùå Taille de fichier trop grande. Max: ${formatFileSize(maxSize)}`, 'danger');
        return false;
    }
    
    return true;
}

// AJOUTEZ cette fonction apr√®s la fonction collectCategoryData (vers la ligne 700) :

function resetCreateForm() {
    document.getElementById('create-form').reset();
    document.getElementById('new-category-fields').innerHTML = '';
    delete currentImageData['new'];
    
    // R√©initialiser avec ModernImageUpload
    if (modernUpload.new) {
        modernUpload.new.removePreview();
    }
    
}

// AJOUTEZ ces fonctions apr√®s resetCreateForm :

// Charger tous les produits
async function loadProducts() {
    try {
        const response = await fetch(`${API_URL}/produits`);
        const data = await response.json();

        if (data.success) {
            allProducts = data.data;
            displayProducts(allProducts);
            populateEditSelect(allProducts);
        }
    } catch (error) {
        console.error('Erreur chargement:', error);
        showMessage('Erreur de chargement des produits', 'danger');
    }
}

// Afficher les produits dans le tableau
function displayProducts(products) {
    const tbody = document.getElementById('products-list');

    if (products.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align: center;">Aucun produit trouv√©</td></tr>';
        return;
    }

    tbody.innerHTML = products.map(product => {
        let imageUrl = product.image || '';
        if (imageUrl) {
            if (imageUrl.startsWith('/')) {
                imageUrl = imageUrl.substring(1);
            }
            if (!imageUrl.startsWith('http') && !imageUrl.startsWith('assets/images/')) {
                imageUrl = `assets/images/${imageUrl}`;
            }
        } else {
            imageUrl = 'data:image/svg+xml,...'; 
        }

        const imageHtml = imageUrl
            ? `<div class="product-image-container">
                 <img src="${imageUrl}" alt="${product.nom}" 
                      class="product-image" 
                      title="üì∑ Survolez pour agrandir - Cliquez pour voir en grand"
                      onclick="showImageModal('${imageUrl}', '${product.nom}')"
                      onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22%3E%3Crect width=%2260%22 height=%2260%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22%3Eüì¶%3C/text%3E%3C/svg%3E'">
               </div>`
            : '<div style="width:60px;height:60px;background:#f0f0f0;border-radius:8px;display:flex;align-items:center;justify-content:center;">üì¶</div>';

        return `
            <tr>
                <td style="text-align: center; padding: 10px;">${imageHtml}</td>
                <td>${product.id}</td>
                <td><strong>${product.nom}</strong></td>
                <td>${product.categorie || '-'}</td>
                <td>${product.prix || '-'}</td>
                <td>${product.top_du_mois ? '‚≠ê' : '-'}</td>
                <td>
                    <div class="actions">
                        <button class="btn btn-warning" onclick="editProduct('${product.id}')" title="Modifier">‚úèÔ∏è</button>
                        <button class="btn btn-danger" onclick="confirmDelete('${product.id}')" title="Supprimer">üóëÔ∏è</button>
                    </div>
                </td>
                <td>
                    <button class="btn btn-info" onclick="previewFicheFromId('${product.id}')" title="Pr√©visualiser la fiche">
                        üìÑ
                    </button>
                </td>
            </tr>
        `;
    }).join('');
}

// Fonction pour afficher l'image en modal
function showImageModal(imageUrl, productName) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        cursor: pointer;
    `;
    
    modal.innerHTML = `
        <div style="position: relative; max-width: 90%; max-height: 90%;">
            <img src="${imageUrl}" 
                 alt="${productName}" 
                 style="max-width: 100%; max-height: 100%; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
            <div style="position: absolute; top: -40px; left: 0; color: white; font-size: 18px; font-weight: bold;">
                üì∑ ${productName}
            </div>
            <div style="position: absolute; top: -40px; right: 0; color: white; font-size: 24px; cursor: pointer;" 
                 onclick="document.body.removeChild(this.closest('div[style*=fixed]'))">
                ‚ùå
            </div>
            <div style="position: absolute; bottom: -40px; left: 50%; transform: translateX(-50%); color: white; font-size: 14px; text-align: center;">
                Cliquez n'importe o√π pour fermer
            </div>
        </div>
    `;
    
    modal.addEventListener('click', () => {
        document.body.removeChild(modal);
    });
    
    const handleEscape = (e) => {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', handleEscape);
        }
    };
    document.addEventListener('keydown', handleEscape);
    
    document.body.appendChild(modal);
}

// Cr√©er un nouveau produit
async function createProduct(event) {
    event.preventDefault();

    const nom = document.getElementById('new-nom').value;
    let titreAffiche = document.getElementById('new-titre-affiche').value.trim();

    if (!titreAffiche) {
        titreAffiche = formatTitreAffiche(nom);
        document.getElementById('new-titre-affiche').value = titreAffiche;
    }

    const productData = {
        nom: nom,
        titre_affiche: titreAffiche,
        categorie: document.getElementById('new-categorie').value,
        prix: document.getElementById('new-prix').value,
        description: document.getElementById('new-description').value,
        lien: document.getElementById('new-lien').value,
        top_du_mois: document.getElementById('new-top').value === 'true',
        fonctionnalites_avancees: document.getElementById('new-fonctionnalites').value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData('new'),
    };

    if (currentImageData['new']) {
        const fileInput = document.getElementById('new-image-file');
        if (fileInput && fileInput.files[0]) {
            productData.image = fileInput.files[0].name;
        }
    }

    try {
        const response = await fetch(`${API_URL}/produits`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(productData)
        });

        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit cr√©√© avec succ√®s!', 'success');
            resetCreateForm();
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        console.error('Erreur cr√©ation:', error);
        showMessage('‚ùå Erreur lors de la cr√©ation', 'danger');
    }
}

// Classe ModernImageUpload
class ModernImageUpload {
    constructor(prefix) {
        this.prefix = prefix;
        this.uploadZone = document.getElementById(`${prefix}-upload-zone`);
        this.fileInput = document.getElementById(`${prefix}-image-file`);
        this.previewContainer = document.getElementById(`${prefix}-preview-container`);
        this.currentFile = null;

        this.setupEventListeners();
    }

    setupEventListeners() {
        if (!this.uploadZone || !this.fileInput) return;

        // Protection anti-doublon
        if (!window.clickProtection) window.clickProtection = {};

        this.uploadZone.addEventListener('click', () => {
            const now = Date.now();
            if (window.clickProtection[this.prefix] && (now - window.clickProtection[this.prefix]) < 1000) {
                return;
            }
            window.clickProtection[this.prefix] = now;
            
            this.fileInput.click();
        });

        this.fileInput.addEventListener('change', (e) => {
            this.handleFiles(e.target.files);
        });

        this.uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.uploadZone.classList.add('dragover');
        });

        this.uploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            this.uploadZone.classList.remove('dragover');
        });

        this.uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            this.uploadZone.classList.remove('dragover');
            this.handleFiles(e.dataTransfer.files);
        });
    }

    handleFiles(files) {
        if (files.length === 0) return;

        const file = files[0];

        if (!file.type.startsWith('image/')) {
            showMessage(`‚ùå ${file.name} n'est pas une image`, 'danger');
            return;
        }

        if (file.size > 5 * 1024 * 1024) {
            showMessage(`‚ùå ${file.name} d√©passe 5MB`, 'danger');
            return;
        }

        this.currentFile = file;
        this.createPreview(file);
        showMessage(`‚úÖ Image ${file.name} s√©lectionn√©e`, 'success');
        
        // IMPORTANT : Assigner le fichier √† l'input pour la soumission
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        this.fileInput.files = dataTransfer.files;
    }

    createPreview(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            // Masquer la zone d'upload et afficher la pr√©visualisation
            this.uploadZone.style.display = 'none';
            
            this.previewContainer.innerHTML = `
                <div class="preview-card-modern" style="border: 2px solid #28a745; border-radius: 10px; background: #f8fff8; padding: 15px; text-align: center;">
                    <img src="${e.target.result}" alt="Aper√ßu" style="width:100%; max-width:250px; height:150px; object-fit:cover; border-radius:8px; margin-bottom:10px;">
                    <div style="font-weight:600; color:#28a745; margin-bottom:5px;">‚úÖ ${file.name}</div>
                    <div style="color:#666; font-size:12px; margin-bottom:10px;">${this.formatFileSize(file.size)}</div>
                    <div class="upload-progress" style="display:none; background:#eee; border-radius:10px; overflow:hidden; margin:10px 0;">
                        <div class="progress-bar" id="progress-${this.prefix}" style="height:20px; background:#28a745; width:0%; transition:width 0.3s;"></div>
                    </div>
                    <div style="display:flex; gap:10px; justify-content:center; margin-top:15px;">
                        <button type="button" class="btn btn-primary" onclick="modernUpload.${this.prefix}.simulateUpload()" style="padding:8px 15px; background:#667eea; border:none; color:white; border-radius:5px; cursor:pointer;">
                            üì§ Traiter
                        </button>
                        <button type="button" class="btn btn-danger" onclick="modernUpload.${this.prefix}.removePreview()" style="padding:8px 15px; background:#dc3545; border:none; color:white; border-radius:5px; cursor:pointer;">
                            üóëÔ∏è Supprimer
                        </button>
                    </div>
                </div>
            `;
            
            this.previewContainer.style.display = 'block';

            // CORRECTION : Stocker le nom du fichier pour la soumission
            currentImageData[this.prefix] = file.name;
        };
        reader.readAsDataURL(file);
    }

    async simulateUpload() {
        const progressBar = document.getElementById(`progress-${this.prefix}`);
        const progressContainer = progressBar.parentElement;

        progressContainer.style.display = 'block';

        for (let i = 0; i <= 100; i += 20) {
            progressBar.style.width = i + '%';
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        showMessage(`‚úÖ Image trait√©e avec succ√®s !`, 'success');
        progressContainer.style.display = 'none';
    }

    removePreview() {
        // Nettoyer la pr√©visualisation
        this.previewContainer.innerHTML = '';
        this.previewContainer.style.display = 'none';
        
        // Nettoyer l'input file
        this.fileInput.value = '';
        this.currentFile = null;

        // Nettoyer les donn√©es stock√©es
        delete currentImageData[this.prefix];

        // R√©afficher la zone d'upload avec le contenu original
        this.uploadZone.innerHTML = `
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">Glissez votre image ici</div>
            <div class="upload-hint">ou cliquez pour parcourir (JPG, PNG, WebP - Max 5MB)</div>
            <input type="file" id="${this.prefix}-image-file" accept="image/*" style="display: none;">
        `;
        this.uploadZone.style.display = 'block';
        
        // Reconfigurer les event listeners apr√®s la remise en place
        this.fileInput = document.getElementById(`${this.prefix}-image-file`);
        this.setupEventListeners();
        
        showMessage('üóëÔ∏è Image supprim√©e', 'info');
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// Initialisation des uploaders modernes
const modernUpload = {};