// Configuration
const API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
  ? 'http://localhost:3000/api'
  : `http://${window.location.hostname}:3000/api`;
let allProducts = [];
let currentEditingId = null;
let currentImageData = {};
let currentFicheData = {};

// Initialisation
document.addEventListener('DOMContentLoaded', () => {
    initImageColumn();
    loadStats();
    loadProducts();
    setupDragAndDrop();
    updateCategoryFields('new');

    // √âcouteurs pour le titre automatique - CORRECTION
    const newNomInput = document.getElementById('new-nom');
    const editNomInput = document.getElementById('edit-nom');

    if (newNomInput) {
        newNomInput.addEventListener('input', function () {
            const titreField = document.getElementById('new-titre-affiche');
            if (titreField && !titreField.value.trim()) {
                titreField.value = formatTitreAffiche(this.value);
            }
        });
    }

    if (editNomInput) {
        editNomInput.addEventListener('input', function () {
            const titreField = document.getElementById('edit-titre-affiche');
            if (titreField && !titreField.value.trim()) {
                titreField.value = formatTitreAffiche(this.value);
            }
        });
    }
});

// G√©rer la s√©lection de fichier HTML
function handleFicheSelect(event, prefix) {
    const file = event.target.files[0];
    if (!file) return;

    // R√©cup√©rer le nom du fichier
    const fileName = file.name;
    const pathInput = document.getElementById(`${prefix}-lien`);

    // Si le champ est vide, mettre juste le nom du fichier
    if (!pathInput.value) {
        pathInput.value = `fiches/${fileName}`;
    }

    // Lire le contenu du fichier HTML (optionnel)
    const reader = new FileReader();
    reader.onload = function (e) {
        currentFicheData[prefix] = {
            name: fileName,
            content: e.target.result
        };
        showMessage(`üìÑ Fichier "${fileName}" s√©lectionn√©`, 'success');
    };
    reader.readAsText(file);
}

// Afficher le s√©lecteur de fiches
async function showFicheSelector(prefix) {
    const selector = document.getElementById(`${prefix}-fiche-selector`);

    if (selector.style.display === 'block') {
        selector.style.display = 'none';
        return;
    }

    try {
        const response = await fetch(`${API_URL}/fiches-list`);
        const data = await response.json();

        if (data.success && data.files.length > 0) {
            // Grouper par dossier
            const grouped = data.files.reduce((acc, file) => {
                if (!acc[file.folder]) acc[file.folder] = [];
                acc[file.folder].push(file);
                return acc;
            }, {});

            let html = '<div style="font-size: 14px;">';
            Object.keys(grouped).sort().forEach(folder => {
                html += `<div style="margin-bottom: 10px;">
                        <strong style="color: #667eea;">üìÅ ${folder}/</strong>
                        <div style="margin-left: 20px; margin-top: 5px;">`;

                grouped[folder].forEach(file => {
                    html += `
                            <div style="padding: 5px; cursor: pointer; hover: background: #f0f0f0;" 
                                 onmouseover="this.style.background='#f0f0f0'" 
                                 onmouseout="this.style.background='none'"
                                 onclick="selectFiche('${prefix}', '${file.path}')">
                                üìÑ ${file.name}
                            </div>`;
                });

                html += '</div></div>';
            });
            html += '</div>';

            selector.innerHTML = html;
            selector.style.display = 'block';
        } else {
            selector.innerHTML = '<p style="color: #888;">Aucun fichier HTML trouv√© dans les dossiers de fiches</p>';
            selector.style.display = 'block';
        }
    } catch (error) {
        console.error('Erreur chargement fiches:', error);
        selector.innerHTML = '<p style="color: #dc3545;">Erreur lors du chargement des fiches</p>';
        selector.style.display = 'block';
    }
}

// S√©lectionner une fiche depuis la liste
function selectFiche(prefix, path) {
    document.getElementById(`${prefix}-lien`).value = path;
    document.getElementById(`${prefix}-fiche-selector`).style.display = 'none';
    showMessage(`‚úÖ Fiche s√©lectionn√©e: ${path}`, 'success');
}

// Initialiser la colonne image si n√©cessaire
async function initImageColumn() {
    try {
        await fetch(`${API_URL}/init-image-column`, { method: 'POST' });
    } catch (error) {
        console.error('Erreur init colonne:', error);
    }
}

// Navigation tabs
function showTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });

    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    document.getElementById(`${tabName}-tab`).classList.add('active');
    event.target.classList.add('active');
}

// Charger les statistiques
async function loadStats() {
    try {
        const response = await fetch(`${API_URL}/stats`);
        const data = await response.json();

        if (data.success) {
            document.getElementById('total-products').textContent = data.stats.total_products || 0;
            document.getElementById('total-categories').textContent = data.stats.total_categories || 0;
            document.getElementById('featured-products').textContent = data.stats.featured_products || 0;
        }
    } catch (error) {
        console.error('Erreur stats:', error);
    }
}

// Charger tous les produits
async function loadProducts() {
    try {
        const response = await fetch(`${API_URL}/produits`);
        const data = await response.json();

        if (data.success) {
            allProducts = data.data;
            displayProducts(allProducts);
            populateEditSelect(allProducts);
        }
    } catch (error) {
        console.error('Erreur chargement:', error);
        showMessage('Erreur de chargement des produits', 'danger');
    }
}

// Afficher les produits dans le tableau
function displayProducts(products) {
    const tbody = document.getElementById('products-list');

    if (products.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align: center;">Aucun produit trouv√©</td></tr>';
        return;
    }

    tbody.innerHTML = products.map(product => {
        let imageUrl = product.image || '';
        if (imageUrl) {
            if (imageUrl.startsWith('/')) {
                imageUrl = imageUrl.substring(1);
            }
            if (!imageUrl.startsWith('http') && !imageUrl.startsWith('assets/images/')) {
                imageUrl = `assets/images/${imageUrl}`;
            }
        } else {
            imageUrl = 'data:image/svg+xml,...'; // ou placeholder
        }

        const imageHtml = imageUrl
            ? `<img src="${imageUrl}" alt="${product.nom}" class="product-image" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22%3E%3Crect width=%2260%22 height=%2260%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22%3Eüì¶%3C/text%3E%3C/svg%3E'">`
            : '<div style="width:60px;height:60px;background:#f0f0f0;border-radius:8px;display:flex;align-items:center;justify-content:center;">üì¶</div>';

        return `
            <tr>
                <td>${imageHtml}</td>
                <td>${product.id}</td>
                <td><strong>${product.nom}</strong></td>
                <td>${product.categorie || '-'}</td>
                <td>${product.prix || '-'}</td>
                <td>${product.top_du_mois ? '‚≠ê' : '-'}</td>
                <td>
                    <div class="actions">
                        <button class="btn btn-warning" onclick="editProduct('${product.id}')">‚úèÔ∏è</button>
                        <button class="btn btn-danger" onclick="confirmDelete('${product.id}')">üóëÔ∏è</button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
}

// G√©rer la s√©lection d'image
async function handleImageSelect(event, prefix) {
    const file = event.target.files[0];
    if (!file) return;

    if (file.size > 10 * 1024 * 1024) {
        showMessage('‚ùå L\'image est trop lourde (max 10MB)', 'danger');
        return;
    }

    const reader = new FileReader();
    reader.onload = function (e) {
        // Stocker l'image en base64
        currentImageData[prefix] = e.target.result;

        // Afficher l'aper√ßu
        document.getElementById(`${prefix}-upload-area`).style.display = 'none';
        document.getElementById(`${prefix}-image-preview`).style.display = 'block';
        document.getElementById(`${prefix}-preview-img`).src = e.target.result;
    };
    reader.readAsDataURL(file);
}

// Supprimer l'image
function removeImage(prefix) {
    delete currentImageData[prefix];
    const uploadArea = document.getElementById(`${prefix}-upload-area`);
    if (uploadArea) uploadArea.style.display = 'block';
    const imagePreview = document.getElementById(`${prefix}-image-preview`);
    if (imagePreview) imagePreview.style.display = 'none';
    const previewImg = document.getElementById(`${prefix}-preview-img`);
    if (previewImg) previewImg.src = '';
    const imageFile = document.getElementById(`${prefix}-image-file`);
    if (imageFile) imageFile.value = '';
}

// Cr√©er un nouveau produit
async function createProduct(event) {
    event.preventDefault();

    // R√©cup√©rer les valeurs
    const nom = document.getElementById('new-nom').value;
    let titreAffiche = document.getElementById('new-titre-affiche').value.trim();

    // Si titre_affiche est vide, le g√©n√©rer automatiquement √† partir du nom
    if (!titreAffiche) {
        titreAffiche = formatTitreAffiche(nom);
        // Optionnel : remplir le champ dans l'interface pour que l'utilisateur voie
        document.getElementById('new-titre-affiche').value = titreAffiche;
    }

    const productData = {
        nom: nom,
        titre_affiche: titreAffiche, // Maintenant toujours rempli
        categorie: document.getElementById('new-categorie').value,
        prix: document.getElementById('new-prix').value,
        description: document.getElementById('new-description').value,
        lien: document.getElementById('new-lien').value,
        top_du_mois: document.getElementById('new-top').value === 'true',
        fonctionnalites_avancees: document.getElementById('new-fonctionnalites').value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData('new'),
    };

    // Ajouter l'image si pr√©sente
    if (currentImageData['new']) {
        const fileInput = document.getElementById('new-image-file');
        if (fileInput && fileInput.files[0]) {
            productData.image = fileInput.files[0].name;
        }
    }

    try {
        const response = await fetch(`${API_URL}/produits`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(productData)
        });

        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit cr√©√© avec succ√®s!', 'success');
            resetCreateForm();
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        console.error('Erreur cr√©ation:', error);
        showMessage('‚ùå Erreur lors de la cr√©ation', 'danger');
    }
}

// Charger un produit pour √©dition
async function loadProductForEdit() {
    const select = document.getElementById('edit-product-select');
    const productId = select.value;

    if (!productId) {
        document.getElementById('edit-form-container').style.display = 'none';
        // AJOUT: Nettoyer les donn√©es d'image quand on d√©s√©lectionne
        delete currentImageData['edit'];
        if (typeof modernUpload !== 'undefined' && modernUpload.edit) {
            modernUpload.edit.removePreview();
        }
        return;
    }

    // AJOUT: Nettoyer avant de charger un nouveau produit
    delete currentImageData['edit'];
    if (typeof modernUpload !== 'undefined' && modernUpload.edit) {
        modernUpload.edit.removePreview();
    }

    try {
        const response = await fetch(`${API_URL}/produits/${productId}`);
        const data = await response.json();

        if (data.success) {
            currentEditingId = productId;
            populateEditForm(data.data);
            document.getElementById('edit-form-container').style.display = 'block';

            // AJOUT: Forcer le rafra√Æchissement du titre apr√®s le chargement
            setTimeout(() => {
                const editNom = document.getElementById('edit-nom').value;
                const editTitre = document.getElementById('edit-titre-affiche');
                if (editTitre && !editTitre.value.trim() && editNom.trim()) {
                    editTitre.value = formatTitreAffiche(editNom);
                }
            }, 100);
        }
    } catch (error) {
        console.error('Erreur chargement:', error);
        showMessage('‚ùå Erreur lors du chargement', 'danger');
    }
}

// Remplir le formulaire d'√©dition
function populateEditForm(product) {
    document.getElementById('edit-nom').value = product.nom || '';
    document.getElementById('edit-titre-affiche').value = product.titre_affiche || ''; // AJOUT
    document.getElementById('edit-categorie').value = product.categorie || '';
    document.getElementById('edit-prix').value = product.prix || '';
    document.getElementById('edit-description').value = product.description || '';
    document.getElementById('edit-lien').value = product.lien || '';
    document.getElementById('edit-top').value = product.top_du_mois ? 'true' : 'false';

    const fonctionnalites = Array.isArray(product.fonctionnalites_avancees)
        ? product.fonctionnalites_avancees.join('\n')
        : '';
    document.getElementById('edit-fonctionnalites').value = fonctionnalites;

    // Afficher l'image existante
    if (product.image) {
        let imageUrl = product.image;
        let imageFileName = product.image;

        // Extraire juste le nom du fichier pour currentImageData
        if (imageUrl.startsWith('assets/images/')) {
            imageFileName = imageUrl.replace('assets/images/', '');
            // Pour l'affichage, garder le chemin complet
            imageUrl = imageUrl;
        } else if (imageUrl.startsWith('/')) {
            imageFileName = imageUrl.substring(1);
            imageUrl = `assets/images/${imageFileName}`;
        } else if (!imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
            // Juste un nom de fichier
            imageFileName = imageUrl;
            imageUrl = `assets/images/${imageUrl}`;
        }

        const editUploadArea = document.getElementById('edit-upload-area');
        const editImagePreview = document.getElementById('edit-image-preview');
        const editPreviewImg = document.getElementById('edit-preview-img');

        if (editUploadArea) editUploadArea.style.display = 'none';
        if (editImagePreview) editImagePreview.style.display = 'block';
        if (editPreviewImg) editPreviewImg.src = imageUrl;
        
        // IMPORTANT: Stocker juste le nom du fichier
        currentImageData['edit'] = imageFileName;
    }

    updateCategoryFields('edit', product.donnees_fiche);
    autoFillFichePath('edit');
}

// Mettre √† jour un produit
async function updateProduct(event) {
    event.preventDefault();

    if (!currentEditingId) return;

    // R√©cup√©rer les valeurs
    const nom = document.getElementById('edit-nom').value;
    let titreAffiche = document.getElementById('edit-titre-affiche').value.trim();

    // Si titre_affiche est vide, le g√©n√©rer automatiquement
    if (!titreAffiche) {
        titreAffiche = formatTitreAffiche(nom);
        document.getElementById('edit-titre-affiche').value = titreAffiche;
    }

    const productData = {
        nom: nom,
        titre_affiche: titreAffiche, // Maintenant toujours rempli
        categorie: document.getElementById('edit-categorie').value,
        prix: document.getElementById('edit-prix').value,
        description: document.getElementById('edit-description').value,
        lien: document.getElementById('edit-lien').value,
        top_du_mois: document.getElementById('edit-top').value === 'true',
        fonctionnalites_avancees: document.getElementById('edit-fonctionnalites').value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData('edit')
    };

    // Ajouter l'image si pr√©sente
    if (currentImageData['edit']) {
        const fileInput = document.getElementById('edit-image-file');
        if (fileInput && fileInput.files[0]) {
            // Nouveau fichier - juste le nom
            productData.image = fileInput.files[0].name;
        } else if (typeof currentImageData['edit'] === 'string' && 
                   currentImageData['edit'].trim() && 
                   !currentImageData['edit'].startsWith('data:')) {
            // Image existante - nettoyer le nom
            let imageName = currentImageData['edit'];
            
            if (imageName.startsWith('assets/images/')) {
                imageName = imageName.replace('assets/images/', '');
            }
            if (imageName.startsWith('/')) {
                imageName = imageName.substring(1);
            }
            
            productData.image = imageName;
        }
    }

    try {
        const response = await fetch(`${API_URL}/produits/${currentEditingId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(productData)
        });

        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit mis √† jour avec succ√®s!', 'success');
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        console.error('Erreur mise √† jour:', error);
        showMessage('‚ùå Erreur lors de la mise √† jour', 'danger');
    }
}

// Supprimer un produit
async function deleteProduct() {
    if (!currentEditingId) return;

    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer ce produit?')) return;

    try {
        // 1. Supprimer la fiche locale AVANT la BDD
        await fetch(`${API_URL}/fiches/${currentEditingId}`, { method: 'DELETE' });

        // 2. Supprimer le produit en BDD
        const response = await fetch(`${API_URL}/produits/${currentEditingId}`, {
            method: 'DELETE'
        });
        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit et fiche supprim√©s avec succ√®s!', 'success');
            document.getElementById('edit-form-container').style.display = 'none';
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        showMessage('‚ùå Erreur lors de la suppression', 'danger');
    }
}

// Supprimer un produit (raccourci depuis la colonne Actions)  
async function confirmDelete(productId) {
    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer ce produit ?')) {
        return;
    }

    try {
        // 1. Supprimer la fiche locale AVANT la BDD
        await fetch(`${API_URL}/fiches/${productId}`, { method: 'DELETE' });

        // 2. Supprimer le produit en BDD
        const response = await fetch(`${API_URL}/produits/${productId}`, {
            method: 'DELETE'
        });
        const data = await response.json();

        if (data.success) {
            showMessage('‚úÖ Produit et fiche supprim√©s avec succ√®s !', 'success');
            loadProducts();
            loadStats();
        } else {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
        }
    } catch (error) {
        showMessage('‚ùå Erreur lors de la suppression', 'danger');
    }
}

// √âditer un produit (raccourci depuis la colonne Actions)
function editProduct(productId) {
    // Aller dans l'onglet modifier
    showTab('modify');

    // S√©lectionner le produit dans la liste d√©roulante
    const select = document.getElementById('edit-product-select');
    if (select) {
        select.value = productId;
        // D√©clencher le chargement du formulaire
        loadProductForEdit();
    } else {
        console.error('‚ùå Element edit-product-select non trouv√©');
    }
}

async function generateFicheFromEdit() {
    if (!currentEditingId) {
        showMessage('S√©lectionnez un produit', 'warning');
        return;
    }

    try {
        const response = await fetch(`${API_URL}/generate-fiche/${currentEditingId}`, {
            method: 'POST'
        });

        const data = await response.json();
        if (data.success) {
            showMessage(`Fiche g√©n√©r√©e: ${data.path}`, 'success');
        } else {
            showMessage(`Erreur: ${data.error}`, 'danger');
        }
    } catch (error) {
        showMessage('Erreur de g√©n√©ration', 'danger');
    }
}

// Peupler le select d'√©dition
function populateEditSelect(products) {
    const select = document.getElementById('edit-product-select');
    select.innerHTML = '<option value="">-- Choisir un produit --</option>';

    const grouped = products.reduce((acc, product) => {
        const cat = product.categorie || 'Sans cat√©gorie';
        if (!acc[cat]) acc[cat] = [];
        acc[cat].push(product);
        return acc;
    }, {});

    Object.keys(grouped).sort().forEach(category => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;

        grouped[category].forEach(product => {
            const option = document.createElement('option');
            option.value = product.id;
            option.textContent = `${product.nom} - ${product.prix || 'N/A'}`;
            optgroup.appendChild(option);
        });

        select.appendChild(optgroup);
    });
}

// Mettre √† jour les champs sp√©cifiques √† la cat√©gorie
function updateCategoryFields(prefix, existingData = null) {
    const category = document.getElementById(`${prefix}-categorie`).value;
    const container = document.getElementById(`${prefix}-category-fields`);

    if (!category) {
        container.innerHTML = '';
        return;
    }

    const fields = getCategorySpecificFields(category);

    // 1. R√©cup√®re les valeurs d√©j√† saisies AVANT de r√©g√©n√©rer le HTML
    let previousValues = [];
    for (let i = 0; i < fields.length; i++) {
        const textarea = document.getElementById(`${prefix}-fiche-${i}`);
        if (textarea) {
            previousValues[i] = textarea.value;
        }
    }

    container.innerHTML = `
        <h3 style="margin-top: 30px; margin-bottom: 20px; color: #667eea;">
            üìã Donn√©es de fiche pour ${category}
        </h3>
        ${fields.map((field, index) => {
            // Priorit√© : existingData (√©dition) > texte d√©j√† saisi > vide
            let value = '';
            if (existingData && existingData[index]) {
                const contenu = existingData[index];
                // G√©rer les \n √©chapp√©s
                const contenuNettoye = contenu.replace(/\\n/g, '\n');

                if (contenuNettoye.includes('\n') && /^[^\w\s]/.test(contenuNettoye)) {
                    value = contenuNettoye.split('\n').slice(1).join('\n');
                } else {
                    value = contenu;
                }
            } else if (previousValues[index]) {
                value = previousValues[index];
            }
            return `
                <div class="form-group">
                    <label>${field.emoji} ${field.label}</label>
                    <textarea 
                        id="${prefix}-fiche-${index}" 
                        rows="3"
                        placeholder="${field.placeholder || ''}"
                    >${value}</textarea>
                </div>
            `;
        }).join('')}
    `;
}

// Obtenir les champs sp√©cifiques √† une cat√©gorie
function getCategorySpecificFields(category) {
    const baseFields = [
        { emoji: "üìù", label: "Description d√©taill√©e", placeholder: "Description compl√®te du produit" },
        { emoji: "üí∞", label: "Prix", placeholder: "Ex: 1299‚Ç¨ - Prix comp√©titif" },
        { emoji: "üß©", label: "Sp√©cifications mat√©rielles", placeholder: "Processeur, RAM, stockage..." }
    ];

    const categorySpecific = {
        'DRONE': [
            { emoji: "üé•", label: "Fonctions vid√©o et photo", placeholder: "R√©solution, stabilisation, modes photo..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Bluetooth, radio..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Pilotage, application mobile..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Batteries, h√©lices, sacoche..." }
        ],
        'CONSOLE': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "R√©solution, taux de rafra√Æchissement..." },
            { emoji: "üïπÔ∏è", label: "Contr√¥leurs et interaction", placeholder: "Manettes, accessoires..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Ethernet, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience de jeu", placeholder: "Interface, exclusivit√©s..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Manettes, c√¢bles..." }
        ],
        'TABLETTE': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution, technologie..." },
            { emoji: "üñäÔ∏è", label: "Accessoires et interaction", placeholder: "Stylet, clavier..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, 4G/5G, Bluetooth..." },
            { emoji: "üéÆ", label: "Applications et usages", placeholder: "Productivit√©, jeux..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'SMARTPHONE': [
            { emoji: "üì∏", label: "Appareil photo", placeholder: "Nombre de capteurs, r√©solution..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "5G, Wi-Fi, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, OS..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Chargeur, c√¢ble..." }
        ],
        'PC GAMING': [
            { emoji: "üéÆ", label: "Performances gaming", placeholder: "GPU, CPU, FPS..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Ethernet, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Refroidissement, bruit..." },
            { emoji: "üîã", label: "Gestion thermique", placeholder: "Ventilation, watercooling..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Souris, clavier..." }
        ],
        'SERVEUR': [
            { emoji: "üñ•Ô∏è", label: "Performances et virtualisation", placeholder: "CPU, RAM, hyperviseur..." },
            { emoji: "üåê", label: "Connectivit√© r√©seau", placeholder: "Ethernet, fibre..." },
            { emoji: "üéÆ", label: "Gestion et monitoring", placeholder: "Logiciels, alertes..." },
            { emoji: "üîí", label: "S√©curit√© et redondance", placeholder: "RAID, alimentation..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'CASQUE AUDIO': [
            { emoji: "üéß", label: "Fonctions audio", placeholder: "ANC, spatialisation..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Bluetooth, filaire..." },
            { emoji: "üéÆ", label: "Confort et utilisation", placeholder: "Poids, coussinets..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'MONTRE CONNECTEE': [
            { emoji: "‚åö", label: "Fonctions sport et sant√©", placeholder: "Cardio, GPS, sommeil..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Bluetooth, Wi-Fi..." },
            { emoji: "üéÆ", label: "Applications et autonomie", placeholder: "App store, batterie..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'CAMERA': [
            { emoji: "üé•", label: "Fonctions vid√©o et photo", placeholder: "R√©solution, formats, modes..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, Bluetooth..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, ergonomie..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Accessoires inclus", placeholder: "Objectifs, c√¢bles..." }
        ],
        'PERIPHERIQUES': [
            { emoji: "üéõÔ∏è", label: "Fonctions avanc√©es", placeholder: "Macros, RGB, capteurs..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Bluetooth, sans fil..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Ergonomie, confort..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." },
            { emoji: "üì¶", label: "Contenu de la bo√Æte", placeholder: "Accessoires inclus..." },
            { emoji: "üîã", label: "Autonomie", placeholder: "Batterie, recharge..." }
        ],
        'CASQUE VR': [
            { emoji: "üïπÔ∏è", label: "Contr√¥leurs et interaction", placeholder: "Manettes, capteurs..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Bluetooth, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience immersive", placeholder: "Champ de vision, confort..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'IMPRIMANTE 3D': [
            { emoji: "üñ®Ô∏è", label: "Fonctions d'impression", placeholder: "Technologie, mat√©riaux..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "USB, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Logiciel, calibration..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'ECRAN TV': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution, HDR..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "HDMI, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, t√©l√©commande..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'VIDEO PROJECTEUR': [
            { emoji: "üé•", label: "Fonctions vid√©o", placeholder: "R√©solution, luminosit√©..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "HDMI, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Installation, r√©glages..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'BOX INTERNET': [
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Ethernet, Wi-Fi..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Interface, installation..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ],
        'TABLEAU INTERACTIF': [
            { emoji: "üñ•Ô∏è", label: "√âcran et affichage", placeholder: "Taille, r√©solution..." },
            { emoji: "üñäÔ∏è", label: "Accessoires et interaction", placeholder: "Stylet, support..." },
            { emoji: "üåê", label: "Connectivit√©", placeholder: "Wi-Fi, HDMI..." },
            { emoji: "üéÆ", label: "Exp√©rience utilisateur", placeholder: "Logiciel, ergonomie..." },
            { emoji: "üõ°Ô∏è", label: "Garantie et support", placeholder: "Dur√©e, SAV..." }
        ]
    };

    return [
        ...baseFields,
        ...(categorySpecific[category] || [])
    ];
}

// Collecter les donn√©es de cat√©gorie AVEC LABELS ET IC√îNES
function collectCategoryData(prefix) {
    const data = [];
    const category = document.getElementById(`${prefix}-categorie`).value;
    const fields = getCategorySpecificFields(category);

    for (let index = 0; index < fields.length; index++) {
        const field = document.getElementById(`${prefix}-fiche-${index}`);
        if (!field) continue;
        // Format : "üìù Description d√©taill√©e\nLe contenu saisi"
        data.push(`${fields[index].emoji} ${fields[index].label}\n${field.value.trim()}`);
    }
    return data;
}

function resetCreateForm() {
    document.getElementById('create-form').reset();
    document.getElementById('new-category-fields').innerHTML = '';

    // AJOUT: Nettoyer compl√®tement les donn√©es d'image
    delete currentImageData['new'];

    // R√©initialiser la zone d'upload moderne
    if (typeof modernUpload !== 'undefined' && modernUpload.new) {
        modernUpload.new.removePreview();
    }
}

// Afficher un message
function showMessage(message, type) {
    const container = document.getElementById('message-container');
    container.innerHTML = `
        <div class="alert alert-${type}">
            ${message}
        </div>
    `;

    setTimeout(() => {
        container.innerHTML = '';
    }, 5000);
}

// Raccourcis clavier
document.addEventListener('keydown', (e) => {
    // Ctrl+N : Nouveau produit
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        showTab('create');
    }

    // Ctrl+E : √âditer
    if (e.ctrlKey && e.key === 'e') {
        e.preventDefault();
        showTab('modify');
    }

    // Ctrl+L : Liste
    if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        showTab('list');
    }
});

// Auto-refresh toutes les 30 secondes
setInterval(() => {
    loadStats();
}, 30000);

// DRAG & DROP MODERNE
class ModernImageUpload {
    constructor(prefix) {
        this.prefix = prefix;
        this.uploadZone = document.getElementById(`${prefix}-upload-zone`);
        this.fileInput = document.getElementById(`${prefix}-image-file`);
        this.previewContainer = document.getElementById(`${prefix}-preview-container`);
        this.currentFile = null;

        this.setupEventListeners();
    }

    setupEventListeners() {
        if (!this.uploadZone || !this.fileInput) return;

        this.uploadZone.addEventListener('click', () => {
            this.fileInput.click();
        });

        this.fileInput.addEventListener('change', (e) => {
            this.handleFiles(e.target.files);
        });

        this.uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.uploadZone.classList.add('dragover');
        });

        this.uploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            this.uploadZone.classList.remove('dragover');
        });

        this.uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            this.uploadZone.classList.remove('dragover');
            this.handleFiles(e.dataTransfer.files);
        });
    }

    handleFiles(files) {
        if (files.length === 0) return;

        const file = files[0];

        if (!file.type.startsWith('image/')) {
            showMessage(`‚ùå ${file.name} n'est pas une image`, 'danger');
            return;
        }

        if (file.size > 5 * 1024 * 1024) {
            showMessage(`‚ùå ${file.name} d√©passe 5MB`, 'danger');
            return;
        }

        this.currentFile = file;
        this.createPreview(file);
        showMessage(`‚úÖ Image ${file.name} s√©lectionn√©e`, 'success');
    }

    createPreview(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.previewContainer.innerHTML = `
                <div class="preview-card-modern">
                    <img src="${e.target.result}" alt="Aper√ßu" style="width:100%;height:200px;object-fit:cover;">
                    <div style="padding:15px;text-align:center;">
                        <div style="font-weight:600;color:#333;margin-bottom:10px;">${file.name}</div>
                        <div class="upload-progress" style="display:none;">
                            <div class="progress-bar" id="progress-${this.prefix}"></div>
                        </div>
                        <div style="display:flex;gap:10px;justify-content:center;margin-top:10px;">
                            <button type="button" class="btn btn-primary" onclick="modernUpload.${this.prefix}.simulateUpload()">
                                üì§ Traiter
                            </button>
                            <button type="button" class="btn btn-danger" onclick="modernUpload.${this.prefix}.removePreview()">
                                üóëÔ∏è Supprimer
                            </button>
                        </div>
                    </div>
                </div>
            `;

            currentImageData[this.prefix] = file.name;
        };
        reader.readAsDataURL(file);
    }

    async simulateUpload() {
        const progressBar = document.getElementById(`progress-${this.prefix}`);
        const progressContainer = progressBar.parentElement;

        progressContainer.style.display = 'block';

        for (let i = 0; i <= 100; i += 20) {
            progressBar.style.width = i + '%';
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        showMessage(`‚úÖ Image trait√©e avec succ√®s !`, 'success');
        progressContainer.style.display = 'none';
    }

    removePreview() {
        this.previewContainer.innerHTML = '';
        this.fileInput.value = '';
        this.currentFile = null;

        // CORRECTION: Nettoyer compl√®tement les donn√©es
        delete currentImageData[this.prefix];

        // R√©afficher la zone d'upload
        const uploadZone = document.getElementById(`${this.prefix}-upload-zone`);
        if (uploadZone) {
            uploadZone.style.display = 'block';
        }
    }
}

// Initialisation des uploaders modernes
const modernUpload = {};

// Remplacer l'ancien setupDragAndDrop
function setupDragAndDrop() {
    setTimeout(() => {
        modernUpload.new = new ModernImageUpload('new');
        modernUpload.edit = new ModernImageUpload('edit');
    }, 500);
}

/**
 * Sauvegarde un produit (cr√©ation ou modification) et g√©n√®re la fiche HTML.
 * @param {'new'|'edit'} mode - 'new' pour cr√©ation, 'edit' pour modification
 */
async function saveProductAndGenerateFiche(mode) {
    const isEdit = mode === 'edit';
    const prefix = isEdit ? 'edit' : 'new';
    const id = isEdit ? currentEditingId : null;

    let titreAfficheValue = document.getElementById(`${prefix}-titre-affiche`).value.trim();
    if (!titreAfficheValue) {
        titreAfficheValue = formatTitreAffiche(document.getElementById(`${prefix}-nom`).value);
    }

    const productData = {
        nom: document.getElementById(`${prefix}-nom`).value,
        titre_affiche: titreAfficheValue,
        categorie: document.getElementById(`${prefix}-categorie`).value,
        prix: document.getElementById(`${prefix}-prix`).value,
        description: document.getElementById(`${prefix}-description`).value,
        lien: document.getElementById(`${prefix}-lien`).value,
        top_du_mois: document.getElementById(`${prefix}-top`).value === 'true',
        fonctionnalites_avancees: document.getElementById(`${prefix}-fonctionnalites`).value.split('\n').filter(f => f.trim()),
        donnees_fiche: collectCategoryData(prefix)
    };

    if (currentImageData[prefix]) {
        const fileInput = document.getElementById(`${prefix}-image-file`);
        if (fileInput && fileInput.files[0]) {
            // Nouveau fichier s√©lectionn√© - stocker JUSTE le nom du fichier
            productData.image = fileInput.files[0].name;
        } else if (typeof currentImageData[prefix] === 'string' && 
                   currentImageData[prefix].trim() && 
                   !currentImageData[prefix].startsWith('data:')) {
            // Image existante - nettoyer pour ne garder que le nom du fichier
            let imageName = currentImageData[prefix];
            
            // Supprimer le chemin assets/images/ s'il existe
            if (imageName.startsWith('assets/images/')) {
                imageName = imageName.replace('assets/images/', '');
            }
            
            // Supprimer le / au d√©but s'il existe
            if (imageName.startsWith('/')) {
                imageName = imageName.substring(1);
            }
            
            productData.image = imageName;
        }
    }

    // Validation
    if (!productData.nom || !productData.categorie) {
        showMessage('‚ö†Ô∏è Nom et cat√©gorie sont obligatoires', 'warning');
        return;
    }

    try {
        // 1. Cr√©ation ou modification du produit
        let response, data;
        if (isEdit) {
            response = await fetch(`${API_URL}/produits/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(productData)
            });
        } else {
            response = await fetch(`${API_URL}/produits`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(productData)
            });
        }
        data = await response.json();

        if (!data.success) {
            showMessage('‚ùå Erreur: ' + data.error, 'danger');
            return;
        }

        const productId = isEdit ? id : data.data.id;

        // 2. G√©n√©rer la fiche HTML
        const ficheResponse = await fetch(`${API_URL}/generate-fiche/${productId}`, {
            method: 'POST'
        });
        const ficheData = await ficheResponse.json();

        if (ficheData.success) {
            showMessage(`‚úÖ Produit ${isEdit ? 'modifi√©' : 'cr√©√©'} et fiche g√©n√©r√©e: ${ficheData.path}`, 'success');
        } else {
            showMessage(`‚úÖ Produit ${isEdit ? 'modifi√©' : 'cr√©√©'} mais erreur fiche: ${ficheData.error}`, 'warning');
        }

        if (!isEdit) resetCreateForm();
        loadProducts();
        loadStats();

    } catch (error) {
        console.error('Erreur:', error);
        showMessage('‚ùå Erreur lors du processus', 'danger');
    }
}

function autoFillFichePath(prefix) {
    const nom = document.getElementById(`${prefix}-nom`).value.trim();
    const categorie = document.getElementById(`${prefix}-categorie`).value.trim();
    if (!nom || !categorie) return;

    // Formatage du chemin
    const catSlug = categorie.toLowerCase().replace(/\s+/g, '-');
    const nomSlug = nom.normalize("NFD").replace(/[\u0300-\u036f]/g, "") // retire accents
        .replace(/[^a-zA-Z0-9]/g, '-') // remplace tout sauf lettres/chiffres par tiret
        .replace(/-+/g, '-') // √©vite les doubles tirets
        .replace(/^-|-$/g, '') // pas de tiret au d√©but/fin
        .toLowerCase();

    const path = `fiches/${catSlug}/${nomSlug}.html`;
    document.getElementById(`${prefix}-lien`).value = path;
}

function formatTitreAffiche(nom) {
    if (!nom) return '';

    // Liste d'acronymes et termes √† garder en majuscules
    const keepUppercase = ['EOS', 'RAM', 'SSD', 'HDD', 'CPU', 'GPU', 'LED', 'LCD', 'HDR', 'USB', 'HD', 'UHD', 'FHD', '4K', '8K', 'PS5', 'PS4', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];

    return nom
        .replace(/-/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .split(' ')
        .map(word => {
            // V√©rifier si le mot (en majuscules) est dans la liste √† conserver en majuscules
            if (keepUppercase.includes(word.toUpperCase())) {
                return word.toUpperCase();
            }
            // Sinon, appliquer la capitalisation standard
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        })
        .join(' ');
}